\documentclass{article}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{float}
\usepackage{minted}
\graphicspath{{./}}
\geometry{a4paper, portrait, margin = 1in}
\title{ROS Made Easy \\0: Introduction and Installation}
\date{\today}
\author{Aniruddh K Budhgavi \\Enigma, IIIT-B}
\begin{document}
    \maketitle
    \section{Important Note}
    This tutorial was created for \textbf{ROS1 Melodic Morenia}
    on \textbf{Ubuntu 18.04 Bionic Beaver}, in \textbf{June 2020}.
    I expect them to become rapidly out of date. It is my hope
    that Team Enigma will continually maintain and update these tutorials.
    \\
    \\
    This tutorial assumes that you are running Ubuntu, and have at least an
    elementary grasp of Python 2.7 and C/C++ .
    \section{Motivation}
    In any field of software engineering, instead
    of repeatedly reinventing the wheel, it is better to
    reuse code. This is accomplished through packages and libraries.
    This same principle of code reuse is true for robotics.
    \\
    \\
    ROS, or the \textbf{Robot Operating System} provides this
    functionality. ROS allows you to separate the problem of
    low-level hardware control from things like motion planning and
    perception. It provides a standardised mechanism for communication
    between multiple processes -- both within a system and across a network.
    It provides tools for robot visualization and simulation
    and for common tasks like inverse kinematics. ROS can be thought
    of as an operating system because it provides all the functions
    that are expected of one. For more details, see \url{http://wiki.ros.org/ROS/Introduction}
    or the first chapter of \emph{A gentle introduction to ROS by Jason M. O Kane}, provided 
    \href{https://github.com/aniruddhkb/enigmatutorials/blob/master/intro2ros/tutorial_docs/agitr-small.pdf}{here}.
    \section{Installation}
        \begin{enumerate}
            \item Follow the installation instructions at \url{http://wiki.ros.org/melodic/Installation/Ubuntu}
            and do a \textbf{full installation}. This is very important, because it provides 
            many add-ons, including the \textbf{Gazebo simulator}. Getting them 
            later on and integrating them with ROS may be difficult.
            \item Follow the complete installation process from beginning to end. Do not skip any steps.
            \item Close all active terminals and open a fresh terminal.
            \item Run the following command to ensure that all is well:
            \begin{minted}{bash}
                export | grep ROS
            \end{minted}
            which should display a bunch of environment variables, like this:
            \begin{minted}{bash}
                declare -x CMAKE_PREFIX_PATH="/home/akb/Documents/dd_robot/devel
                    :/home/akb/Documents/four_dof_arm/devel
                    :/home/akb/Documents/localROS2/devel
                    :/home/akb/Documents/localROS/devel
                    :/opt/ros/melodic"
                declare -x GAZEBO_MODEL_PATH="/home/akb/Documents/localROS2/src
                    :/usr/share/gazebo-9/models
                    :/home/akb/Documents/four_dof_arm/src
                    :/home/akb/Documents/dd_robot/src"
                declare -x LD_LIBRARY_PATH="/home/akb/Documents/dd_robot/devel/lib
                    :/home/akb/Documents/four_dof_arm/devel/lib
                    :/home/akb/Documents/localROS2/devel/lib
                    :/home/akb/Documents/localROS/devel/lib
                    :/opt/ros/melodic/lib"
                declare -x PKG_CONFIG_PATH="/home/akb/Documents/dd_robot/devel/lib/pkgconfig
                    :/home/akb/Documents/four_dof_arm/devel/lib/pkgconfig
                    :/home/akb/Documents/localROS2/devel/lib/pkgconfig
                    :/home/akb/Documents/localROS/devel/lib/pkgconfig
                    :/opt/ros/melodic/lib/pkgconfig"
                declare -x ROSLISP_PACKAGE_DIRECTORIES="/home/akb/Documents/dd_robot/devel
                /share/common-lisp
                    :/home/akb/Documents/four_dof_arm/devel/share/common-lisp
                    :/home/akb/Documents/localROS2/devel/share/common-lisp
                    :/home/akb/Documents/localROS/devel/share/common-lisp"
                declare -x ROS_DISTRO="melodic"
                declare -x ROS_ETC_DIR="/opt/ros/melodic/etc/ros"
                declare -x ROS_MASTER_URI="http://localhost:11311"
                declare -x ROS_PACKAGE_PATH="/home/akb/Documents/dd_robot/src
                    :/home/akb/Documents/four_dof_arm/src
                    :/home/akb/Documents/localROS2/src
                    :/home/akb/Documents/localROS/src
                    :/opt/ros/melodic/share"
                declare -x ROS_PYTHON_VERSION="2"
                declare -x ROS_ROOT="/opt/ros/melodic/share/ros"
                declare -x ROS_VERSION="1"
            \end{minted}
            \item Also, try:
            \begin{minted}{bash}
                roscore
            \end{minted}
        \end{enumerate}
    \section{Core concepts}
        \subsection{Packages}
            \begin{enumerate}
                \item All ROS software is organized into packages. A package consists of:
                \begin{enumerate}
                    \item A folder having the same name as the package name. The folder \textbf{is} the package.
                    \item A manifest file, \texttt{package.xml} which provides information about the package. Most importantly, it lists the packages
                    that this package depends on.
                    \item A CMake configuration file, \texttt{CMakeLists.txt} which is used to compile the package.
                    \item The source code of the package executables.
                    \item Custom messages and services. 
                \end{enumerate}

                \item Example packages are \texttt{std\_msgs}, \texttt{turtlesim}, \texttt{gazebo\_ros} and \texttt{rviz}.
                \item Use the \texttt{rospack} command to view information about packages. As a start, try:
                \begin{minted}{bash}
                    rospack list-names
                \end{minted}
                which should provide you with a list of the currently installed ROS packages.
                \item Also try:
                \begin{minted}{bash}
                    rospack find turtlesim
                \end{minted}
                which should give you the path to the {\texttt turtlesim} package, \texttt{/opt/ros/melodic/share/turtlesim}.
                \item To know more about rospack, try:
                \begin{minted}{bash}
                    rospack help
                \end{minted}
                \item We will later see how to create and build our own packages.
            \end{enumerate}
        \subsection{Nodes}
            \begin{enumerate}
                \item A running instance of a ROS process is a node. The phrase "running instance" is key --
                an executable file sitting idle on your hard disk is \textbf{not} a node.
                \item A node can:
                \begin{itemize}
                    \item Compute something, just like any regular C++ or Python program.
                    \item Communicate with other nodes, or with the running instance of ROS.
                \end{itemize}
                \item There can be multiple nodes running on the same system, as well as multiple nodes across different systems.
                \item The code for a node can be written in any language that supports the ROS client library, though official support is right 
                now limited to C++ and Python.
                \item Nodes can communicate through \emph{messages}, \emph{services} and the \emph{parameter server}.
            \end{enumerate}
        \subsection{Messages and topics}
            \begin{enumerate}
                \item The primary method of communication between ROS nodes is through messages on topics.
                \item Communication through topics is many-to-many in nature. Nodes can \emph{subscribe} to (receive messages from) a topic,
                and \emph{publish} to (send messages to) a topic. When a message is published to a topic, all the nodes that have subscribed to that 
                topic receive that message.
                \item Topics, then, are like message boards or forums. It is not known which node published which message (unless the message itself contains this).
                \item Every topic has a message type associated with it. Only messages of that type can be published to that topic. You can think of message type as being analogous to data type.
                The messages resemble structs in C.
                \item To view the message types available, use the command:
                \begin{minted}{bash}
                    rosmsg list
                \end{minted}
                \item To view the format of a message, use \texttt{rosmsg show <msg-type>}. For example,
                \begin{minted}{bash}
                    rosmsg show geometry_msgs/Twist
                \end{minted}
                Output:
                \begin{minted}{bash}
                    geometry_msgs/Vector3 linear
                        float64 x
                        float64 y
                        float64 z
                    geometry_msgs/Vector3 angular
                        float64 x
                        float64 y
                        float64 z
                \end{minted}
                \item An important point is that though the communication through topics is many-to-many,
                the messages themselves are directly transmitted between the publisher and subscribers
                 -- there is no "server" that acts as an intermediary.
                
                \item To know more about \texttt{rosmsg}, try \texttt{rosmsg help}.
            \end{enumerate}
        \subsection{Services}
            \begin{enumerate}
                \item Services provide one-to-one communication between nodes.
                \item A ROS node (service provider) can provide a service which can be \emph{called}
                by another node (client).
                \item When a service is called, a request message is sent from the client to the service provider,
                which can reply with a response message. These request/response messages are different from topic/messages. 
            \end{enumerate}
        \subsection{The parameter server}
            \begin{enumerate}
                \item The parameter server is a place where globally-accessible data can be stored.
                \item Every instance of ROS has one parameter server, and every node on that instance can 
                get and set parameters on that server.
                \item These parameters are typically initialized when a ROS instance is started.
            \end{enumerate}
        \subsection{The master}
            \begin{enumerate}
                \item The ROS master is a program which must be started before any nodes are activated.
                \item The ROS master provides many functions, including:
                \begin{itemize}
                    \item Naming and registering nodes.
                    \item Establishing publisher-subscriber connections and tracking topics.
                    \item The parameter server.
                    \item Tracking services.
                    \item Debugging tools.
                \end{itemize}
            \end{enumerate}
    \section{Looking forward}
        I understand if so far, it's been quite theoretical and dry. But this is necessary to get a good grasp of the 
        fundamentals of ROS. Next time, we'll see how to start the ROS master, start nodes, and publish messages to topics.
\end{document}